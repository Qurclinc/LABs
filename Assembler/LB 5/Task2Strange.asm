ORG 100h

MOV SI, OFFSET msg   ; SI указывает на начало строки
CALL GetLength       ; Вычисляем длину строки (в CX)

CMP CX, 10           ; Если длина > 10
JA CutString         ; Обрезать строку
JMP ExtendString     ; Иначе дополнить

; ===== Обрезка строки до 6 символов =====
CutString:
    MOV BYTE PTR [SI+6], '$'  ; Обрезаем строку после 6 символов
    JMP PrintString           ; Переход к выводу

; ===== Дополнение строки символами 'o' до 12 символов =====
ExtendString:
    MOV DI, CX          ; DI содержит текущую длину строки
    ADD DI, SI          ; DI теперь указывает на конец строки
    MOV AL, 'o'         ; Символ для дополнения

FillLoop:
    INC DI              ; Переходим к следующему символу
    MOV [DI], AL        ; Записываем 'o'
    INC CX              ; Увеличиваем счетчик длины
    CMP CX, 12          ; Достигли 12 символов?
    JB FillLoop         ; Если нет, продолжаем

    MOV BYTE PTR [DI+1], '$' ; Устанавливаем конец строки

; ===== Вывод строки =====
PrintString:
    MOV DX, SI
    MOV AH, 09h
    INT 21h
    INT 20h

; ===== Функция определения длины строки =====
GetLength PROC
    MOV CX, 0        ; Обнуляем счетчик длины
FindEnd:
    MOV AL, [SI]     ; Загружаем текущий символ
    CMP AL, '$'      ; Проверяем, не конец ли строки
    JE Done          ; Если конец, выходим
    INC SI           ; Переходим к следующему символу
    INC CX           ; Увеличиваем счетчик длины
    JMP FindEnd      ; Проверяем следующий символ
Done:
    SUB SI, CX       ; Восстанавливаем SI к началу строки
    RET
GetLength ENDP

; ===== Исходная строка =====
msg DB "Aboba$", 0
